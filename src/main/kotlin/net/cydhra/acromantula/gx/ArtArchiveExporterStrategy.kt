package net.cydhra.acromantula.gx

import net.cydhra.acromantula.features.exporter.ExporterStrategy
import net.cydhra.acromantula.workspace.WorkspaceService
import net.cydhra.acromantula.workspace.filesystem.FileEntity
import java.io.OutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder

/**
 * Export .art banks of CT3. They contain a set of GXT(X) files, which are GT Texture files.
 */
class ArtArchiveExporterStrategy : ExporterStrategy {
    companion object {
        const val FIXED_HEADER_SIZE = 4
        const val IMAGE_OFFSET_SIZE = 4
    }

    override val name: String = "art"

    override fun exportFile(fileEntity: FileEntity, outputStream: OutputStream) {
        if (!fileEntity.isDirectory) {
            throw IllegalArgumentException("only directories can be exported as art files")
        }

        // collect all files that will be added to the achive
        val totalFiles = mutableListOf<FileEntity>()
        collectTotalFiles(totalFiles, listOf(fileEntity))

        // TODO multiple problems here:
        //  - all files are buffered within the application, potentially using up all memory. Since we need to know
        //  the size of all files beforehand, find a preferably elegant way to safe on memory
        //  - the order of files is kind of arbitrary. I suspect the order is imposed by the database primary key,
        //  which is good, if no additional files are added or removed by the user. But if the user should be able to
        //  replace files, the order must be restored somehow. Since the files are not named, either the
        //  lexicographical order of the file names generated by the import strategy should be used, or the user
        //  should provide an arbitrary order.
        val totalFilesBuffers = mutableListOf<ByteArray>()

        val headerBuffer = ByteBuffer
                .allocate(FIXED_HEADER_SIZE + IMAGE_OFFSET_SIZE * totalFiles.size)
                .order(ByteOrder.LITTLE_ENDIAN)

        // put image count
        headerBuffer.putInt(totalFiles.size)

        // put image offset table
        // I have to read all files into memory here, because I need to know their sizes to write the header
        var currentOffset = headerBuffer.capacity()
        for (file in totalFiles) {
            val buffer = WorkspaceService.getFileContent(file).readAllBytes()
            totalFilesBuffers += buffer
            headerBuffer.putInt(currentOffset)
            currentOffset += buffer.size
        }

        assert(headerBuffer.hasArray())
        outputStream.write(headerBuffer.array())

        for (buffer in totalFilesBuffers) {
            outputStream.write(buffer)
        }
    }

    private fun collectTotalFiles(totalFiles: MutableList<FileEntity>, files: List<FileEntity>) {
        for (file in files) {
            if (file.isDirectory) {
                val subFiles = WorkspaceService.getDirectoryContent(file)
                collectTotalFiles(totalFiles, subFiles)
            } else {
                totalFiles += file
            }
        }
    }
}